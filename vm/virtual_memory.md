
# 需求

## Basic data structures
1. 你需要在不分页的内存中实现这些数据结构, 确保这些数据结构里的内容的全局可访问性, 
    不会因为页表切换就无法访问
2. 你可以用bitmap来辅助你进行data structure的设计, 但bitmap是定长的, 你可以给它添加
    修改长度的功能
### Supplemental Page Table
1. 你需要SPT的原因至少有两点, 当发生页面错误时, 内核需要知道错误的页面中存储了什么数据
    方便内核分配新的页面, 或将内存中的页面拉回来. 第二个原因时, 内核需要在进程终止时
    查询SPT来确定这个进程申请了哪些页面, 最终根据SPT的指引把这些内存资源释放掉.
2. 你实现SPT的方法至少有两种, 基于数据段的或基于单个页面的, 你也可以用Page Table本身作为
    SPT的索引, 但这需要你修改pagedir.c中的内容, 并根据PTE的格式进行涉及
3. SPT最重要的用户就是Page Fault Handler, 这个函数需要在每次发生Page Fault时进行如下操作
    a. handler需要通过SPT定位该进程访问的数据在哪里, 在swap或文件中就需要把它们搬运到内存中
        如果进程试图访问内核内存空间, 或访问只读页面, 或访问不存在的数据, handler应该立即杀死
        进程, 如果你实现了sharing 它要求访问的页面可能已经在frame table中
    b. 从frame table中获得一个页面来存放数据
    c. 对这个页面进行操作, 将其清零或将swap和文件中的数据搬运进来
    d. 将出错的虚拟地址对应的PTE指向你上面刚刚分配并设置好的页面, 你可以用pagedir.c中的函数

### Frame Table
1. FT存储的是每个物理页面和虚拟内存页面的对应关系, 其中的每个项目(entry)对应一个物理页面
    指向一个用户虚拟页面, 每项包含一个指针指向user page 
2. 只有当没有页面是空闲的时候(所有frame都被占满), 才启动页面驱逐策略
3. FT也需要向使用palloc_get_page()申请页面, 一定要使用PAL_USER参数!
4. 当你有一个页面需要驱逐, 而swap分区已满, 你需要立刻触发kernel panic
5. 驱逐策略:
    a. 利用你实现的驱逐算法选择一个页面
    b. 移除任何指向该页面的PTE(来自用户进程)
        如果你实现了sharing, 那么一个frame可能被多个进程引用, 否则一个frame只能被一个page引用
    c. 将page写入file或swap

### Swap Table
1. ST的任务是追踪记录正在使用的或者空闲的swap slot(槽位)
2. 当有某个页面被驱逐时, ST需要找到一个空闲的slot将其插入, 并记录有关该page的信息
3. 当该page被要求返回到内存中时, 需要查找ST以恰当的将其搬运到内存中, 并free其对应的slot
4. swap分区应该储存在块设备中, 使用block_get_role()来获取一个块设备
5. swap分区应该是惰性加载的, 你不应该预先在swap中存储任何数据, 直到有需要的时候


## Paging
1. 需要为可执行文件实现分页管理, 所有的页面应该是惰性加载的, 即, 只有出现Page Fault时
    才加载页面
2. 实现页面驱逐, 当内存满时, 驱逐dirty bit为1的页面到磁盘上, 绝不能驱逐dirty bit为0的页面
    或只读页面
3. 实现全局页面置换算法, 比如LRU的近似: Clock或Second Chance
4. 需要处理并发, 即如果某个进程Page Fault并且需要IO操作, 其他不Fault的进程需要正常运行
    而不需要IO的Page Fault的进程也要正常运行
5. 你需要修改process.c中的load_segemnt()函数, 修改其中的page_read_bytes()和page_zero_bytes()有关事项

## Stack Growth
1. 在Project 1, 2中, 栈空间被限制在PHY_BASE以下的一页中(只有一页的空间!)
    现在你需要实现栈增长, 当栈增长超过PGSIZE时, 为进程分配新的页面
2. 你需要设计一个机制, 分辨对于栈指针以下的访问到底是真的栈增长, 还是野指针的胡乱访问
3. 很不幸的是, x86的PUSH指令在压入第一个4byte后才检查栈指针的合法性(它先压入数据, 然后调整栈指针, 而不是反过来)
    这会导致在栈指针以下4byte处发生Page Fault, PUSHA指令一次性压入32个Byte, 这会在栈指针以下32byte处
    发生Page Fault
4. 为了解决以上的问题, 你需要在Page Fault Handler中读取当前用户进程的esp来确认是否是栈增长, 然而, 
    你需要知道, 只有当用户进程向内核切换时, CPU才会将用户进程的esp保存在中断帧中, 如果用户进程本身
    发生了页面错误, CPU不会存储esp(真的吗?), 在这种情况下, 读取中断帧中的esp是未定义行为
    你需要用其他的方法把esp记录下来, 比如记录在struct thread结构体中
5. 你需要保证栈空间不会超过上限(一般是8MB), 这个限制需要是用户可调节的
6. 所有进程的栈所处的第一个页面不应该是惰性加载的, 你应该预先加载好, 并在里面放入参数
7. 为栈增长开辟的页面也是驱逐的对象! 它们可以被驱逐到内存中!

## Memory Mapped Files
1. 总而言之, 你需要把文件映射到内存中
2. 你需要实现mmap, munmap两个系统调用, mmap负责将整个文件映射到一块连续的内存区域上, 并返回一个独一无二的整数
    作为标识
3. 对于mmap, 你需要实现文件的惰性加载, 只有当发生缺页错误时才把文件从磁盘中拿到内存里, 同时, 你不应该在此时
    使用swap分区作为驱逐页面的归宿, 相反, 你应该使用文件所处的位置(文件本身)作为页面驱逐的目的地
    每次页面驱逐都会更新磁盘上的文件
4. 此时你还不能实现文件增长, 如果文件的大小不是PGSIZE的整数倍, 那么文件末尾所处的页面一定会有一些不属于该文件的部分
    把它们全部设为0, 并且在写回时忽略这些0.
5. 如果mmap失败则返回-1, 此时在内存上不应该有任何映射
6. 有以下情况时失败: 文件长度为0byte, addr不是PGSIZE的整数倍, map的内存区域覆盖了另一个map, 比如其他进程的stack区
    或其他进程申请分配的页面, page 0必须是unmap的, fd == 0或1必须失败.
7. 当程序自己退出或被kernel杀死时, 必须unmap其所有的页面, 当前内存中被修改的页面会被写回文件, 未修改的页面则不会
    这些页面最终会从进程持有的页面列表中被清除
8. 在mapping过程中, 如果进程关闭或销毁了文件, mapping也不应该终止, 除非进程本事使用了munmap 系统调用
    此时你需要使用file_reopen()保存一个可用的文件对象供mapping使用
9. 如果两个或更多进程map了同一个文件, 你不需要做文件之间的同步, 换言之, 每个进程眼里所见的文件可以是不同的
    (即使它们引用了同一个文件对象)

## Accessing User Memory
1. 你需要在kenerl执行系统调用时, 访问属于用户的内存页面
2. 用户的内存页面可能根本不在内存中! 它们可能被驱逐到swap分区或者在文件中(使用了mmap并且尚未加载到内存中)
    甚至当kernel访问页面时, 该页面也很可能被驱逐! 以上这些情况都会导致Page Fault
3. 你需要恰当的处理这些Page Fault 或者使用一些手段, 保证Page Fault不会发生
4. 你需要保证当某个页面内存储了kernel需要的资源时, 这个页面绝对不会发生Page Fault
    比如, 你需要保证当使用file_read向user提供的buffer中写入数据时, 在buffer内存内不会发生Page Fault
    因为一旦在file_read过程中发生了Page Fault, 那么你将无法再次唤醒用于读取文件的外部设备来继续读取(断点续传no!)
5. 你可以使用"pinning"的方式阻止这这种Page Fault的发生, 保证所需的页面一定在内存中不会被驱逐, 
    比如在frame table entry中添加一个变量来作为不被驱逐的标志位.


## 设计思路
### 明确需求:
1. SPT可能寻求FT给出一个空闲的页面, 需要直接操作内核内存分配函数palloc_get_page()
2. FT需要使用类似键值对的形式存储物理页面和用户页面的对应关系
3. FT需要一个标志位标记pinning page 
4. FT只管理在内存中的页面, 内存外的页面由SPT和ST追踪, page被evict后, FT应该清除该项
5. Frame Table的作用是实现页面驱逐, 要在FT上实现Clock算法

1. SPT应该是一个二重哈希表, SPT大表中根据进程信息存储对应的哈希表, 每个子表中的元素即为对应进程的页面的元数据
     其中存储该页面的具体信息(位置:内存中/文件中/swap中), 权限(RW/RO), 是否sharing, 对应的PTE, 
    对应的物理内存地址, 对应的FT node, 对应的swap node
    当进程需要显式地为自己接下来请求的页面设定细节(比如在读取可执行文件时, 设定内存页面为只读), 就先建立一个带有元数据的SPT entry
    PF handler在每次分配页面时都会查询在SPT中是否有未映射物理页面但带有元数据的entry, handler会根据元数据对页面进行相应设置
    当PF发生, 但handler没找到元数据时, handler会按默认方式分配内存(可读可写, 不sharing, 可evict)
2. FT应该是一个链表, 基本不会有在FT上直接进行的查找操作, (查找主要在SPT和ST中进行), 每次handler分配新页面时, 要使用frame.h提供的函数
    由frame系统来分配页面(你不能在handler或其他任何地方使用palloc_get_page()之类的, 直接控制系统内存池的函数!)
    每次分配后FT都会插入新的页面, 由它实现evict功能
3. ST表应该是一个哈希表, key为PTE数据, value为在swap.disk中的位置
4. ST, FT以及mmap的设计应该会用到bitmap, 用来确保数据不会相互覆盖




